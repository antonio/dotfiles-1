#+TITLE: Configuring Emacs
#+AUTHOR: Sondre Nilsen
#+EMAIL: nilsen.sondre@gmail.com
#+PROPERTY: tangle "~/.emacs.d/init.el"

* Preface
I've always been a fan of ~org-babel~, even from before I used
Emacs. Now I can finally document the whys and hows without tons of
comments everywhere.

** Setup

I currently run the Emacs 25.1 pretest release on OS X.

* Packages
Load Marmalade and Melpa for more packaging goodness.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-archives
        '(("gnu" . "http://elpa.gnu.org/packages/")
          ("org" . "http://orgmode.org/elpa/")
          ("melpa" . "http://melpa.org/packages/")
          ("marmalade" . "http://marmalade-repo.org/packages/")))
  (package-initialize)
#+END_SRC

And since I am going to be using ~use-package~ for installing and configuring
packages as well, I need to make sure that is installed as well.
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

Furthermore, I want to automatically compile my emacs files.
#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :ensure t
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)
#+END_SRC

* General preferences
For settings that don't really belong in any specific category. Like default
behaviour and such.

** Name
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Sondre Nilsen"
        user-mail-addres "nilsen.sondre@gmail.com")
#+END_SRC
** Memory
Luckily we aren't in the 1990, so we can allow more than Eight Megabytes™.
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-treshold (* 100 1024 1024)) ;; 100mb
#+END_SRC
** UTF8
Using anything other than UTF8 anywhere is pretty stupid, so we don't do that.
#+BEGIN_SRC emacs-lisp
  (set-language-environment 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq buffer-file-coding-system 'utf-8)
#+END_SRC
** Startup screen
It gets a bit tiring of seeing the same startup screen every time, especially
since I have no real interest in it. So we'll just disable it and change the
default display message.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        initial-scratch-message ""
        initial-major-mode #'emacs-lisp-mode)
  (defun display-startup-echo-area-message ()
    (message ""))
#+END_SRC
** Yes and/or no
It's annoying having to write ~yes~ or ~no~ instead of just ~y~ or ~n~. So we
change that as well.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Disable the bell
Because god fucking dammit, that shit gets annoying really quick.
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore
        visible-bell t)
#+END_SRC
** Global syntax highlighting
This is just a sane default in my opinion, when do you not want to have
something syntax highlighted? Yeah, thought so too.
#+BEGIN_SRC emacs-lisp
  (use-package font-lock
    :init
    (setq font-lock-maximum-decoration t)
    :config
    (global-font-lock-mode t))
#+END_SRC
** Disable bidirectional text
I have no need for it as none of the languages I know use right-to-left, most
of them just use a bunch of parentheses.
#+BEGIN_SRC emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)
#+END_SRC
** Spaces, not tabs
I know this is controversial and all that jazz, but I am a firm believer in
spaces instead of tabs. I like the consistency and it's just the way I've been
rocking since I started using any kind of text editing.
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

However, I prefer using two space indents over four space indents. No real
reason here to be honest, I just prefer how compact it looks.
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC
** Ignore case on completing file names
Because that's just plain annoying. And you know it.
#+BEGIN_SRC emacs-lisp
  (setq read-file-name-completion-ignore-case t)
#+END_SRC
** White space
Deleting trailing whitespace is something that Vim does by default, and most
other editors I've tried (mostly Sublime) did it as well. And sentences should
not end on double spaces, that's just nuts. And finally, files should require a
final newline.
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (setq sentence-end-double-space nil
        require-final-newline t)
#+END_SRC
** Auto fill
Another thing I liked in Vim, it would automatically wrap your lines when they
got too long. It's a bit annoying having to ~M-q~ all the time when writing
this file for example.
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 79)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Spell checking
Amazingly, Emacs has a feature that will automatically check your spelling. Is
there anything Emacs cannot do? Here we enable it in all text major modes and
it's programming mode, which only checks comments. Flyspell can use several
different spelling programs, I settled on ~hunspell~ as it's actively
maintained and downloaded ~LibreOffices~ dictionaries for Norsk Bokmål and
American English.
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :config
    (setq-default ispell-program-name "hunspell")
    (setq ispell-really-hunspell t
          ispell-dictionary "en_US"
          ispell-local-dictionary-alist
          '(
            ("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8)
            ("nb_NO" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8)))
    (add-hook 'text-mode-hook #'turn-on-flyspell)
    (add-hook 'prog-mode-hook #'flyspell-prog-mode))
#+END_SRC

**** Automatically switch between dictionaries
I am bilingual with a slight trilingual spell during high school. So it'd be
nice to be able to switch between Norwegian and English when using it.
#+BEGIN_SRC emacs-lisp
  (let ((langs '("en_US" "nb_NO")))
    (setq lang-ring (make-ring (length langs)))
    (dolist (elem langs) (ring-insert lang-ring elem)))
  (defun my/cycle-languages ()
    "Changes the dictionary"
    (interactive)
    (let ((lang (ring-ref lang-ring -1)))
      (ring-insert lang-ring lang)
      (ispell-change-dictionary lang)
      (message "Dictionary changed to %s" lang)))
#+END_SRC
** Backups, history and saves
By default Emacs saves backup files and autosave files into the same directory
as the current file you're editing so you end up with a bunch of ~filename.el~~
and ~filename.el#~ and so on files. Instead I want them saved to the emacs home
folder in their own folders.
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(concat user-emacs-directory "saves")))
        auto-save-file-name-transforms
        `((".*" ,(concat user-emacs-directory "auto-save") t))
        backup-by-copying t
        version-control t
        delete-old-versions t)
#+END_SRC

There's also a way to save the recent files and recent prompts you use in
Emacs, so we'll change their save file and length.
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (progn
      (setq recentf-save-file (concat user-emacs-directory "recentf")
            recentf-max-saved-items 100
            history-length 100))
    :config
    (recentf-mode 1))
#+END_SRC

And then the settings for the prompts.
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (setq savehist-file (concat user-emacs-directory "savehist"))
    :config
    (savehist-mode t))
#+END_SRC

Lastly, Emacs has a way to save where in a file you were when you were last
editing in, even between sessions of using the program. Which is really neat.
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (setq save-place-file (concat user-emacs-directory "saveplace"))
    :config
    (setq-default save-place t))
#+END_SRC
** Copying and pasting
Because why would you not want to be able to copy and paste outside Emacs, and
some sane defaults from [[https://github.com/technomancy/better-defaults/blob/master/better-defaults.el][better-defaults.el]].
#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t
        select-enable-primary t
        save-interprogram-paste-before-kill t
        mouse-yank-at-point t)
#+END_SRC
** Always start maximized
#+BEGIN_SRC emacs-lisp
  (toggle-frame-maximized)
#+END_SRC
** OS X
I am currently using OS X, so I want to make sure it can read my ~$PATH~.
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

Then we need to set some OS X specific settings, I want ~Command~ for example
to be the meta key in Emacs, and not ~Option~, and enable the clipboard to work
outside Emacs.
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns))
    (setq ns-pop-up-frames nil
          mac-option-modifier nil
          mac-command-modifier 'meta))
#+END_SRC
** Secrets
Cause some things are better left outside of version control...
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda ()
                               (let ((private-file (concat user-emacs-directory "secrets.el")))
                                 (when (file-exists-p private-file)
                                   (load-file private-file)))))
#+END_SRC
* Looks
Settings that change how the interface looks and behaves.
** Font
Good fonts are important and I normally change quite often between some, but
have now settled for Source Code Pro. It has all the bells and whistles that I
want and looks really good.
#+BEGIN_SRC emacs-lisp
  (set-frame-font "Source Code Pro")
  (set-face-attribute 'default nil
                      :height 120
                      :weight 'normal)
#+END_SRC
** Real estate
I don't need any of these as they just end up taking up my precious screen real
estate.
#+BEGIN_SRC emacs-lisp
  (when window-system
    (tooltip-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode 1)
    (scroll-bar-mode -1))
#+END_SRC

** Line spacing
This isn't probably the most useful thing, but the space it gives everything
makes everything seems so light. I really enjoy it, although I doubt it's
something for everyone.
#+BEGIN_SRC emacs-lisp
  (setq-default line-spacing 0.15)
#+END_SRC
** Fringe
Even though I hardly use the fringe for anything, it's still nice to have to
separate the borders of the screen and the contents of the buffer.
#+BEGIN_SRC emacs-lisp
  (fringe-mode '(1 . 10))
#+END_SRC
** Relative line numbers
This is probably one of my favorite features from Vim, makes it incredibly easy
to both see where you are on the screen and move around within the
buffer.
#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :ensure t
    :config
    (setq linum-relative-current-symbol ""
          linum-relative-format " %3s ")
    (custom-set-faces '(linum-relative-current-face
                        ((t :inherit linum :foreground "black" :background "white" :weight bold)))))

  (add-hook 'prog-mode-hook #'linum-relative-mode)
#+END_SRC

*** TODO Text modes
However, this doesn't work in org-mode, so we'll need to make it use only
regular line numbers instead.
** Git gutter
This is yet a thing that I found and loved in Vim, show git changes in the
gutter. I looked at ~git-gutter~ which is the most updated one, but I want to
display my gutter on the right, and then I had to use ~git-gutter-fringe~ which
isn't updated nearly as much. I looked at a few more variants of ~git-gutter~
but after a while found ~diff-hl~ which does most of what I want.

However, I'd like it to show signs instead of colors, but it doesn't support
that. Might have to write my own after all...
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :init
    (setq diff-hl-side 'left)
    :config
    (global-diff-hl-mode))
#+END_SRC
** Cursor
I have a hard time with using a box for the cursor compared to a bar, since I
never seem to figure out which side of the character the cursor is on. So we
change the cursor to be a bar instead.
#+BEGIN_SRC emacs-lisp
  (setq-default cursor-type 'bar)
#+END_SRC
** Window title
I'd like to be able to see which file I'm editing from the frame, not just
~Emacs@hostname~.
#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '(:eval (concat (buffer-name) " :: GNU Emacs")))
#+END_SRC
** Unique buffer names
Occasionally you'll have multiple files with the same file name open, and Emacs'
default behavior for this is just to append ~<2>~, which is both ugly and not
informative. I use ~uniquify~ to solve that.
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :init
    (progn
      (setq uniquify-buffer-name-style 'forward)))
#+END_SRC
** Mode line
*** Hide line and column numbers
#+BEGIN_SRC emacs-lisp
  (line-number-mode 0)
  (column-number-mode 0)
#+END_SRC
* Behavior
For things that change how things behave but aren't related to either the
interface (which should only change how things looks) or general preferences
(which only change sane defaults). With this I mean things like ~avy~ and
~smex~ and such.
** Avy
In Vim I used [[https://github.com/easymotion/vim-easymotion][vim-easymotion]] quite a bit to move around in the buffer I was in,
and of course Emacs has something like it as well.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
    (avy-setup-default))
#+END_SRC
* Evil
** Installing
I won't claim that I'm a huge Vim power user, because I'm not, but after having
used it for a while (and only scratching the surface), I absolutely cannot live
without it. So by extension I need Evil in Emacs for some lovely Vim on Emacs
action.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config
    (evil-mode 1))
#+END_SRC
** Leader and chords
I switched the leader key in Vim to ~<SPC>~ almost immediately after starting
to use it, so I don't even know what it is set to by default. So I need it to
be space here too.

I also have a few chords set up that I use for various commands:
| Chord     | Description                | Function             |
|-----------+----------------------------+----------------------|
| ~<SPC> w~ | Save current buffer        | ~save-buffer~        |
| ~<SPC> o~ | Open file                  | ~find-file~          |
| ~<SPC> b~ | Switch between buffers     | ~switch-to-buffer~   |
| ~<SPC> l~ | Change dictionary language | ~my/cycle-languages~ |
| ~<SPC> j~ | Jump to thing              | ~avy-goto-char~      |
| ~<SPC> J~ | Jump to things on STEROIDS | ~avy-goto-word-0~    |
#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t
    :config
    (setq general-default-keymaps 'evil-normal-state-map)
    (setq general-default-prefix "<SPC>")
    (general-define-key "w" 'save-buffer
                        "o" 'find-file
                        "b" 'switch-to-buffer
                        "l" 'my/cycle-languages
                        "j" 'avy-goto-char
                        "J" 'avy-goto-word-0))
#+END_SRC
** Using ~jk~ to exit insert mode
~ESC~ is just too far to reach for mere mortals, and I even play piano. So I
changed the way you exit Insert Mode in Vim to be ~jk~ to help my pinky. For
this we have to use a package called ~KeyChord~.
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :ensure t
    :config
    (setq key-chord-two-keys-delays 0.5)
    (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
    (key-chord-mode 1))
#+END_SRC
** Make ~ESC~ quit everything
In Vim once your press ~ESC~ you stop everything, in Emacs you end up having to
button mash it quite a few times to exit all the way out. Thankfully, ~davvil~
on Github has it solved [[https://github.com/davvil/.emacs.d/blob/master/init.el][here]].
#+BEGIN_SRC emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
    In Delete Selection mode, if the mark is active, just deactivate it;
    then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))
  (define-key evil-normal-state-map [escape] 'keyboard-quit)
  (define-key evil-visual-state-map [escape] 'keyboard-quit)
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
  (global-set-key [escape] 'evil-exit-emacs-state)
#+END_SRC
** Keybinds
*** Change ~:~ to ~;~
I read about this on reddit while I still used Vim and I really enjoyed it. It
also helps that I'm lazy and don't want to press ~S-:~.
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd ";") 'evil-ex)
#+END_SRC
*** Moving between buffers
I use Tmux in my terminal and bound the key to switch between windows in it to
be ~C-[hjkl]~, and did the same in Vim to be able to move between windows in
both Tmux and Vim. So to have the same in Emacs would be nice, even though I
could use ~C-w [hjkl]~.
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
#+END_SRC
* Keybinds
** Extra leader keybinds
Because I want only the most important keybinds to be bound via ~<SPC>~, I have
set up ~,~ as a secondary leader key with commands that I use quite often but
aren't as "important" as the ones bound to the main leader.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :config
    (setq secondary-leader ",")
    (general-define-key :prefix secondary-leader
                        "e" 'eval-buffer))
#+END_SRC
* Programming
** General preferences
*** Electric pair mode
~electric-pair-mode~ automatically inserts the correct closing bracket or
parentheses, but I only want this in programming modes.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'electric-pair-mode)
#+END_SRC
*** Aggressive indentation
I'm sure we have all struggled with indentation getting absolutely fucked up
when we change something in a file. With ~aggressive-indent-mode~ you don't
have to worry about that anymore.
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode))
#+END_SRC
*** Parentheses
I mostly dabble in Scheme or LISP, and so parentheses are pretty important to
me. We already have them auto-close, now we want them to automatically show the
matching parenthesis, brackets and so on, and do it without delay.
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :config
    (show-paren-mode)
    (setq show-paren-delay 0))
#+END_SRC

Then, to make the parentheses even more pretty, we are going to use
~rainbow-delimeters~ to make em purdy.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
*** Prettify symbols
There really is no practical purpose in my opinion for making symbols prettier
besides making them prettier. Yo dawg. It just looks cool.
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
  (setq prettify-symbols-unprettify-at-point 'right)
#+END_SRC
**** LISPS and Scheme
So we don't litter everything with tons of symbols that are for some languages
but aren't for other, we'll set the symbols on a language by language basis.
#+BEGIN_SRC emacs-lisp
  (setq lisps-symbols
        '(("lambda" . ?λ)
          ("nil" . ?∅)))

  (dolist (mode '(emacs-lisp-mode-hook
                  inferior-lisp-mode-hook
                  scheme-mode-hook))
    (add-hook mode
              '(lambda ()
                 (setq prettify-symbols-alist lisps-symbols))))
#+END_SRC
* Org mode
** Get Org mode from Git
This is mostly because I like being able to have the latest and greatest of
things, however with ~use-package~ and packages that come with Emacs you need
to do something extra for it to fetch the latest version. For more info see
[[https://github.com/jwiegley/use-package/issues/319][here]]. We have already added the Org mode ELPA repo.

Then we need to make sure we install the latest version of Org. To do this we
actually need to ensure ~org-plus-contrib~.
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib)
#+END_SRC
** Syntax highlighting
#+BEGIN_SRC emacs-lisp
  (setq-default org-src-fontify-natively t)
#+END_SRC
** Intend Org headers
I accidentally found out about this function in a comment on StackOverflow, but
I can't figure out where I found it. What it does is indent the heading
according to their level. So a ~**~ is indented to the right under a ~*~ and so
on.
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
#+END_SRC
** Org babel languages
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (emacs-lisp . t)
     (sh . t)))
#+END_SRC
* Functions
** Tangle dotfiles and byte compile Emacs settings
After having tried (and successfully) organized my Emacs init file, I've
decided I want to do it with all my other dotfiles as well. However, it'd be
nice if it as well auto-tangled the files on save, as I do with my ~init.org~
file.

I tried splitting out a separate function to byte compile my ~init.el~ file
separately from the tangle function, but this didn't work as they fired
asynchronously, when I wanted it synchronously. So I added in another
conditional to check whether the file is ~emacs.org~.
#+BEGIN_SRC emacs-lisp
  (defun my/tangle-dotfiles ()
    "If the current file is in '~/.dotfiles', the code blocks are tangled"
    (when (equal (file-name-directory (directory-file-name buffer-file-name))
                 (concat (getenv "HOME") "/.dotfiles/"))
      (org-babel-tangle)
      (message "%s tangled" buffer-file-name)
      (when (equal (buffer-file-name)
                   (expand-file-name "~/.dotfiles/emacs.org"))
        (byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook #'my/tangle-dotfiles)
#+END_SRC
