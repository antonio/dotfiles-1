#+TITLE: Emacs settings
#+AUTHOR: Sondre Nilsen
#+EMAIL: nilsen.sondre@gmail.com
#+PROPERTY: header-args :tangle ~/.emacs.d/init.el

* Introduction
This is my Emacs configuration, there are many like it but this one is mine. I
really don't recommend other people use it directly, if anything you can steal,
copy and/or take inspiration from it.

** Table of contents                                          :TOC:noexport:
- [[#introduction][Introduction]]
  - [[#version][Version]]
  - [[#begin][~(begin)~]]
- [[#initial-configuration][Initial configuration]]
  - [[#gc-threshold][GC threshold]]
  - [[#start-emacs-server][Start Emacs server]]
  - [[#use-package][~use-package~]]
  - [[#show-boot-time][Show boot time]]
- [[#keybindings][Keybindings]]
  - [[#which-key][~which-key~]]
  - [[#general][~General~]]
  - [[#evil-mode][evil-mode]]
- [[#core-settings][Core settings]]
  - [[#sane-defaults][Sane defaults]]
  - [[#core-editor-settings][Core editor settings]]
  - [[#auto-completion][Auto completion]]
  - [[#git][Git]]
  - [[#magit][Magit]]
  - [[#spell-checking][Spell checking]]
  - [[#syntax-checking][Syntax checking]]
  - [[#ivy-counsel-and-swiper][Ivy, Counsel and Swiper]]
- [[#appearance][Appearance]]
  - [[#theme][Theme]]
  - [[#fonts][Fonts]]
  - [[#mode-line][Mode line]]
  - [[#line-numbers][Line numbers]]
  - [[#highlight-current-line][Highlight current line]]
  - [[#buffer-names][Buffer names]]
  - [[#hide-and-seek][Hide and seek]]
  - [[#assorted][Assorted]]
- [[#org-mode][Org mode]]
  - [[#settings][Settings]]
  - [[#agenda][Agenda]]
  - [[#functions][Functions]]
- [[#latex][Latex]]
  - [[#auctex][AUCTeX]]
  - [[#reftex][RefTEX]]
- [[#programming][Programming]]
  - [[#lisp][LISP]]
  - [[#sql][SQL]]
- [[#outro][Outro]]

** Version
I'm currently running the HEAD-version of Emacs from their Git repository for
some glorious proper line numbering. As soon as this release is out I'll be
switching to good old regular Emacs.

** ~(begin)~
And with that we can start.

* Initial configuration
** GC threshold
We don't want Emacs to be Eight Megabytes And Constantly Swapping.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 100 1024 1024)
        gc-cons-percentage 0.6)
#+END_SRC

** Start Emacs server
As far as I'm aware this is a setting that sets it so that the ~emacsclient~ is
always running in the background so you don't have to start Emacs whenever you
open a new file.
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC

** ~use-package~
This is the goody goodness that makes this whole thing work. It defers loading
of packages so Emacs starts up faster, it makes configuration of packages very
modular and is just all around great. I really enjoy using it.

First off the bat though we need to set up where Emacs gets the packages from.
#+BEGIN_SRC emacs-lisp
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org" . "https://orgmode.org/elpa/")))
#+END_SRC

Then we can set some initial settings for packages.

~load-prefer-newer~ always attempts to load the most recent version of a file,
even if it has been byte compiled already.

#+BEGIN_SRC emacs-lisp
  (setq-default load-prefer-newer t
#+END_SRC

And we'll disable packages at startup to save some time, and it's redundant
since we're using ~use-package~.

#+BEGIN_SRC emacs-lisp
  package-enable-at-startup nil)
#+END_SRC

Then we initialize the package settings.

#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC

Make sure that ~use-package~ and ~Delight~ are always installed. Delight is used
to hide major and minor modes in the mode line.

#+BEGIN_SRC emacs-lisp
  (unless (and (package-installed-p 'use-package)
               (package-installed-p 'delight))
    (package-refresh-contents)
    (package-install 'use-package t)
    (package-install 'delight t))
#+END_SRC

And make sure they are loaded and ready when we start Emacs to avoid any
roundabout errors where we require ~use-package~ but ~use-package~ isn't loaded
so we can't load packages and so on.

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'use-package)
    (require 'delight))
#+END_SRC

Finally we'll set some settings for ~use-package~. First off, we'll always
ensure that packages are ensured. This means that for internal packages we'll
have to say ~:ensure nil~, otherwise fun stuff happens.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t
#+END_SRC

Then we'll make sure that when we are executing a ~:init~ block the package
we're declaring this in is actually installed.

#+BEGIN_SRC emacs-lisp
  use-package-check-before-init t
#+END_SRC

And finally, we'll always defer loading packages. This means that if we
absolutely require some package to be loaded and not lazy loaded we have to use
~:demand t~ on it.

#+BEGIN_SRC emacs-lisp
  use-package-always-defer t)
#+END_SRC

And completely at the end, we'll tell Emacs to use some new byte code stuff. No
idea what it does because the manual doesn't say. But newer is always better?

#+BEGIN_SRC emacs-lisp
  (setq byte-compile--use-old-handlers nil)
#+END_SRC
* Keybindings
Any and all settings related to keybindings go here, this includes configuration
for Evil and setting up the general key map that I'll be using to edit files.
** ~which-key~
You've probably seen this in Spacemacs where it's used extensively to display
what keybindings are available in different major modes and in general. I like
this idea and I'll be stealing it. Neato.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :demand t
    :config
    (progn
      (which-key-mode)
      (setq which-key-sort-order 'which-key-key-order-alpha
            which-key-sort-uppercase-first nil
            which-key-prefix-prefix nil
            which-key-idle-delay 0.3)))
#+END_SRC
** ~General~
For any and all binding goodness I'll use ~General~. It's pretty awesome.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :config
    (progn
      (general-evil-setup)))
#+END_SRC
*** Major keybinding
This is where the major stuff happens.

#+BEGIN_SRC emacs-lisp
  (general-create-definer leader-keys
                          :states '(emacs normal visual motion insert)
                          :prefix "SPC"
                          :non-normal-prefix "M-m")

  (general-create-definer major-mode-leader-keys
                          :states '(emacs normal visual motion insert)
                          :prefix "'"
                          :non-normal-prefix "SPC-m")
#+END_SRC

*** Assorted rebinds
1. Change from the default, built-in Evil-search to Swiper.

#+BEGIN_SRC emacs-lisp
  (general-nmap "/" 'swiper)
#+END_SRC

2. Automatically switch between the current buffer and the last one used in this
frame.

#+BEGIN_SRC emacs-lisp
  (defun my--switch-buffer (&optional window)
    (interactive)
    (let ((current-buffer (window-buffer window))
          (buffer-predicate
           (frame-parameter (window-frame window) 'buffer-predicate)))
      ;; switch to first buffer previously shown in this window that matches
      ;; frame-parameter `buffer-predicate'
      (switch-to-buffer
       (or (cl-find-if (lambda (buffer)
                         (and (not (eq buffer current-buffer))
                              (or (null buffer-predicate)
                                  (funcall buffer-predicate buffer))))
                       (mapcar #'car (window-prev-buffers window)))
           ;; `other-buffer' honors `buffer-predicate' so no need to filter
           (other-buffer current-buffer t)))))
#+END_SRC
** evil-mode
After having used Vim for quite a while doing my editing and such of basically
anything I'm addicted to the way you move and manipulate text with it. Even
though I'm god awful with it. So obviously we'll use ~evil~ for good.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init (setq evil-want-integration nil)
    :config (evil-mode t))
#+END_SRC

*** evil-collection
For one single organism trying to organize and create consistent keybindings is
a daunting task, I have had this with trying to configure Vim keybindings in Emacs
for various modes that I use. I just end up with a hodgepodge of assorted
keybindings bound to my leader key that doesn't really make sense. This is where
~evil-collection~ comes in, it's a community based project for configuring as much
of Emacs as possible to consistent and good Vim keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :after evil
    :config (evil-collection-init))
#+END_SRC
*** evil-escape
However, if you've ever used Vim you know that using ~ESC~ to escape out of any
mode is god awful. So we won't do that.

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :delight evil-escape-mode
    :init (evil-escape-mode 1)
    :config
    (progn
      (setq-default evil-escape-key-sequence "jk")))
#+END_SRC
*** evil-surround
And then we'll add ~evil-surround~ because it's really neat being able to change
the delimiters surrounding something on the fly.

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :init (global-evil-surround-mode 1))
#+END_SRC
*** evil-commentary
This is a neat package if you comment out code a lot. Like I do.

#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :delight evil-commentary-mode
    :init (evil-commentary-mode))
#+END_SRC
*** evil-goggles
This is a really neat extension that I found on /r/emacs, what it does is
display visual hints when doing various actions while editing to highlight what
changed. Really useful for both pair programming and seeing what you did
yourself.

#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :config
    (progn
      (evil-goggles-mode)))
#+END_SRC
* Core settings
We'll configure anything that relates to how I want the core of Emacs to behave
and work, regardless of whether or not it's an actual core feature.

** Sane defaults
Emacs is an ancient thing and as such it does indeed have a lot of cruft from
times that have long since passed, so we'll create some settings to make it feel
and work a bit more modern.

*** Locale
For some reason Emacs can't read the ~LOCALE~ of my computer, so I'll have to
import them into Emacs.

#+BEGIN_SRC emacs-lisp
  (setenv "LANG" "en_US.UTF-8")
#+END_SRC
*** UTF-8
We're in the 21st century so we are all using UTF-8, right?

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'set-charset-priority)
    (set-charset-priority 'unicode))
  (prefer-coding-system                   'utf-8)
  (set-terminal-coding-system             'utf-8)
  (set-keyboard-coding-system             'utf-8)
  (set-selection-coding-system            'utf-8)
  (setq locale-coding-system              'utf-8)
  (setq-default buffer-file-coding-system 'utf-8)
#+END_SRC
*** y tho
To yes or to y

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Delete selection
By default Emacs doesn't replace text you select but rather just starts
inserting text at the cursor. It's really annoying.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC
*** Custom file
Since we'll be tangling this file into ~init.el~ you need to save all the custom
stuff to it's own file because otherwise it would just be overwritten all the
time. So we'll set our own custom file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
#+END_SRC

And load it, but give no errors if it doesn't exist and no messages.

#+BEGIN_SRC emacs-lisp
  (load custom-file t t)
#+END_SRC
*** Hide startup messages
I don't really care about all the messages about GNU and stuff whenever I boot
Emacs. Don't get me wrong, I love GNU software and FSF and whatnot, I just don't
want the reminder in my editor all the damn time.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
  (defun display-startup-echo-area-message ())
#+END_SRC
*** new emacs, who dis
And don't ring the bloody bell whenever you scroll /anywhere/. It's fucking
annoying.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil
        ring-bell-function #'ignore)
#+END_SRC
** Core editor settings
Then we'll configure the built-in modes and such that control how the editor
itself works.

*** Auto revert
This makes it so files are automatically refreshed if they are changed on the
disk, and we'll enable it globally for any buffer.
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :ensure nil
    :init
    (progn
      (setq auto-revert-verbose nil
            global-auto-revert-non-file-buffers t)
      (global-auto-revert-mode)))
#+END_SRC
*** ~electric-pair-mode~
Which does essentially exactly what it says, it pairs things up.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'electric-pair-mode)
#+END_SRC
*** Parenthesis
Next up we'll make sure that parenthesis light up when we look at them straight.
Or even sideways.
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :ensure nil
    :init (show-paren-mode 1)
    :config
    (progn
      (setq-default show-paren-delay 0
                    show-paren-highlight-openparen t
                    show-paren-when-point-inside-paren t)))
#+END_SRC
*** ~recentf~
Keep a list of the most recently used files that have been opened to make it
quicker to access them from the minibuffer.
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :ensure nil
    :init
    (progn
      (add-hook 'find-file-hook (lambda () (unless recentf-mode
                                             (recentf-mode)
                                             (recentf-track-opened-file))))
      (setq recentf-save-file (concat user-emacs-directory "recentf")
            recentf-max-saved-items 1000
            recentf-auto-cleanup 'never
            recentf-filename-handlers '(abbreviate-file-name))))
#+END_SRC
*** Saving history
~savehist~ is a minor mode that automatically saves your files periodically and
when you close Emacs. Not really sure why it's not enabled by default.
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :ensure nil
    :init
    (progn
      (setq savehist-file (concat user-emacs-directory "savehist")
            enable-recursive-minibuffers t
            savehist-save-minibuffer-history t
            history-length 1000
            savehist-autosave-interval 60
            savehist-additional-variables '(mark-ring
                                            global-mark-ring
                                            search-ring
                                            regexp-search-ring
                                            extended-command-history))
      (savehist-mode t)))
#+END_SRC
*** Saving places
~saveplace~ is supposed to save the location of where you were last in a file in
Emacs but for some reason I've never been able to make it work.
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :ensure nil
    :init
    (progn
      (setq save-place-file (concat user-emacs-directory "places"))
      (save-place-mode)))
#+END_SRC
*** Backups
By default Emacs does some really weird shit with backup files and such, it
saves them to a bunch of assorted files in the folder of the file you're
currently editing, which is very annoying when using Git.
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "saves/")))
        auto-save-file-name-transforms `((".*" ,(concat user-emacs-directory "auto-save") t))
        auto-save-list-file-name (concat user-emacs-directory "autosave")
        abbrev-file-name (concat user-emacs-directory "abbrev_defs")
        make-backup-files nil
        backup-by-copying t
        version-control t
        delete-old-versions t)
#+END_SRC
*** White space
Emacs doesn't handle trailing spaces or anything like that very well by default,
it's far too aggressive for my tastes, so we'll use ~ws-butler~ to fix this.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :init (ws-butler-global-mode 1))
#+END_SRC
*** Indentation
When using LISP and languages that can easily be automatically indented, I like
using ~aggressive-indent~ to do this even as I'm editing code.

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :init (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode))
#+END_SRC
*** Delimiters
Some times I like my delimiters to look dashing. Like a rainbow.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
*** Assorted settings
Anything else goes here.
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 2
                sentence-end-double-space nil
                vc-follow-symlinks t
                fill-column 80)
  (setq help-window-select t
        compilation-scroll-output 'first-error
        save-interprogram-paste-before-kill t)
  (add-hook 'text-mode-hook #'auto-fill-mode)
#+END_SRC
** Auto completion
Like pretty much everyone else using auto completion in Emacs, we'll be doing
this with ~Company~. It's great.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :delight
    :init
    (progn
      (global-company-mode)
      (setq company-idle-delay 0.2
            company-minimum-length 2
            company-require-match nil
            company-dabbrev-ignore-case nil
            company-dabbrev-downcase nil
            company-tooltip-align-annotations t)))
#+END_SRC
** Magit
If you've never used ~git~, then you might actually live under a rock. It's
awesome. And we'll be using the even more awesome ~Magit~ to work with it. First
off we'll enable some built-in modes that comes with ~Magit~ that we can use for
editing various ~git~ files.

#+BEGIN_SRC emacs-lisp
  (use-package gitattributes-mode)
  (use-package gitconfig-mode)
  (use-package gitignore-mode)
#+END_SRC

And then we can use ~Magit~ and install a compatibility layer for Evil.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :delight auto-revert-mode
    :general
    (general-define-key
     "C-x g" '(:which-key "git")
     "C-x g s" '(magit-status :which-key "git status")))
  (use-package evil-magit
    :after magit
    :init (evil-magit-init))
#+END_SRC
*** Diff-hl
Lots of people use the various ~git-gutter~ packages but I've found that
~diff-hl~ is far better than all of them, mostly because of how configurable it
is and the fact that it /bloody/ works.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :init
    (progn
      (setq diff-hl-side 'left
            diff-hl-margin-symbols-alist
            '((insert . "+") (delete . "-") (change . "~")
              (unknown . "?") (ignored . "i")))
      (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
      (diff-hl-margin-mode)
      (global-diff-hl-mode)))
#+END_SRC
** Spell checking
Spelling is hard yo. So we'll check that shit.

*** Flyspell
And then we can use Flyspell to actually check the spelling. Neato.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :init
    (setenv "DICTIONARY" "en_US")
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (dolist (mode-hook '(text-mode-hook LaTeX-mode-hook))
      (add-hook mode-hook (lambda () (flyspell-mode))))
    :config
    (when (executable-find "hunspell")
      (setq-default ispell-program-name "hunspell")
      (setq ispell-really-hunspell t))
    (setq ispell-dictionary "en_US"
          flyspell-use-meta-tab nil
          flyspell-issue-message-flag nil
          flyspell-issue-welcome-flag nil))
#+END_SRC

*** Ivy and Flyspell
Since we're using Ivy we can use it instead of the default flyspell buffer/popup
to change words. Which is a lot nicer, let me tell you.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct-ivy
    :commands (flyspell-correct-ivy)
    :general (:keymaps 'flyspell-mode-map
                       "C-;" 'flyspell-correct-previous-word-generic)
    :init (setq flyspell-correct-interface #'flyspell-correct-ivy))
#+END_SRC
** Syntax checking
Now that we can assure ourselves that we don't make spelling mistakes anymore,
it's time to make sure we never make any syntax mistakes either. Or at least a
man can dream.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
  :init
    (progn
      (global-flycheck-mode t)
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
    :config
    (progn
      (setq flycheck-standard-error-navigation nil
            flycheck-indication-mode 'right-fringe)))
#+END_SRC
** Ivy, Counsel and Swiper
~abo-abo~ has created an awesome set of packages to help with completions,
specifically when finding files, running commands and such. It does not compete
with Company for example.

To begin with, they're all included in the ~counsel~ package, so we'll install
that first. Then we can start using Ivy for switching buffers and all it's
glorious goodies.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :demand
    :delight
    :general
    (general-define-key
     "C-x C-f" 'counsel-find-file
     "C-x C-r" 'counsel-recentf
     "C-h f" 'counsel-describe-function
     "C-h v" 'counsel-describe-variable)
    :config
    (progn
      (counsel-mode)))

  (use-package ivy
    :demand
    :delight
    :config
    (progn
      (ivy-mode)
      (setq ivy-use-virtual-buffers t
            enable-recursive-minibuffers t
            ivy-count-format "%d%d ")))

  (use-package swiper
    :demand
    :general
    (general-define-key "C-S" 'swiper))
#+END_SRC

*** Switch between buffers
#+BEGIN_SRC emacs-lisp
  (defun my--switch-window ()
    (interactive)
    (let (;; switch to first window previously shown in this frame
          (prev-window (get-mru-window nil t t)))
      ;; Check window was not found successfully
      (unless prev-window (user-error "Last window not found."))
      (select-window prev-window)))
#+END_SRC
* Appearance
Emacs does indeed look like it never properly left the eighties, but you can
configure it to be properly dashing. And I like my things ~T H I C C~. I mean
fancy. I mean dashing.

** Theme
I like my themes to be really minimalistic and clean.

#+BEGIN_SRC emacs-lisp
  (use-package tao-theme
    :demand t
    :init (load-theme 'tao-yang t))
#+END_SRC
** Fonts
Probably the most important thing to change in /any/ editor in my opinion is the
font. I'm currently using ~Fira Mono~ as my font of choice. I really enjoy
it.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family "Fira Mono"
                      :height 100)
  (set-face-attribute 'variable-pitch nil
                      :family "Fira Mono"
                      :height 100)
#+END_SRC
** Mode line
The biggest offender in my opinion is the mode-line, it's ugly as sin and nearly
impossible to decipher unless you know what all the hyphens and stars and whatnot
mean.

*** Date and time
By default it doesn't show the date or time, and since I mostly run Emacs
full screen I always lose track of what the time is. So we'll set this in the
mode-line. And of course it's going to be in the only proper format, 24hr. But
we'll hide the information about load on the computer because it's useless.

#+BEGIN_SRC emacs-lisp
  (setq display-time-day-and-date t
        display-time-24hr-format t
        display-time-default-load-average nil)
  (display-time-mode t)
#+END_SRC

** Line numbers
As an avid Evil and VIM user, not having line numbers feels wrong. And they have
to be relative. Previously I used to use packages for this, but they all had
their own issues. They displayed the wrong line number in Org files whenever you
folded a section, they made the margin hard to use and configure, and so on.
Luckily with Emacs 26 they implemented a native version of this, so I'll be
using that. Huzzah.

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers 'visual
                display-line-numbers-current-absolute t
                display-line-numbers-width-start t
                display-line-numbers-width 2
                display-line-numbers-widen nil)
#+END_SRC

And because of this we can just disable the fringe all together.

#+BEGIN_SRC emacs-lisp
  (set-fringe-style '(0 . 16))
#+END_SRC
** Highlight current line
Also a thing from my days with VIM. This just creates a line that highlights the
current line your cursor is on.

#+BEGIN_SRC emacs-lisp
  (use-package hl-line
    :ensure nil
    :init (global-hl-line-mode t)
    :config
    (progn
#+END_SRC

Then we'll hide the highlighted line in all the windows that are inactive.

#+BEGIN_SRC emacs-lisp
  (setq hl-line-sticky-flag nil
#+END_SRC

And set it to be global as well for good measure.

#+BEGIN_SRC emacs-lisp
  global-hl-line-sticky-flag nil)))
#+END_SRC
** Buffer names
Instead of having duplicate buffers be names ~foo<1>~ and ~foo<2>~ we can use
~uniquify~ to set them to be their paths instead, so it'll be ~quix/bar/foo~ and
~bar/foo~ instead.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :ensure nil
    :init
    (progn
      (setq uniquify-buffer-name-style 'forward)))
#+END_SRC
** Hide and seek
I don't use the menu or tool bars. Or rather, most of the time I wish I did but
then I remember that I stole these settings a long time ago and don't want to
feel like a Emacs newbie by using them.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
#+END_SRC
** Assorted
And then we have the leftovers that will helps us make Emacs look good. First on
the chopping block is setting the line spacing a bit higher than the default so
it doesn't look so cramped.

#+BEGIN_SRC emacs-lisp
  (setq-default line-spacing 0.15
#+END_SRC

Customize the cursor type to be a bit thinner than normal and a bar instead of a
block, not really sure how this works with Evil but hey, I've always used this
setting.

#+BEGIN_SRC emacs-lisp
  cursor-type '(bar . 2)
#+END_SRC

And finally we'll set the title of our Emacs window. I'll call my Emacs Amalthea
because it's a cool name and I can imagine it's my own distribution that is
popular. Yay me.

#+BEGIN_SRC emacs-lisp
  frame-title-format '("Amalthea :: %b"))
#+END_SRC
* Org mode
Even though Emacs comes bundled with Org installed I do want to make sure I have
the latest version, to do this with ~use-package~ you have to ensure that
~org-plus-contrib~ is installed alongside ~org~.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :config
    (progn
      (setq org-use-sub-superscripts '{}
            org-export-with-sub-superscripts '{}
            org-export-use-babel nil
            org-preview-latex-default-process 'dvipng
            org-pretty-entities t
            org-list-allow-alphabetical t)))
#+END_SRC

** Settings
*** Syntax highlighting
Apparently this is enabled by default now but just to be sure we'll set its
setting regardless.
#+BEGIN_SRC emacs-lisp
  (setq-default org-src-fontify-natively t)
#+END_SRC

*** Indent headers
I find that indenting headers makes it easier to at a glance see what's what in
the document, so we'll do that. And for some reason it's a mode that shows on
the modeline so we'll hide that.

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (delight 'org-indent-mode)
#+END_SRC

*** Hide emphasis markers
Probably my favorite feature in Org, well, probably but, but I absolutely love
it, this hides the markers that makes text show as italics or code etc. It's
nice.

#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

*** Org babel
Add the languages I use to the ~org-babel~ language list so you don't get errors
everywhere.

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)
     (sql . t)))
#+END_SRC
*** Export to HTML
Apparently you need this package to export Org documents to HTML, which I use
for SQL to help my classmates.

#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

And to make it look like something out of the 2000s instead of the 1980s we'll
use ~ox-twbs~ to make it purdy.

#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    ;; stupid hack required to make it work >:(
    :init (require 'ox-twbs))
#+END_SRC
*** Table of Contents in Org-files
This whole file has gotten a bit unwieldy in size, even though it's nowhere near
the size of some of the configurations I've seen around. However, we'll include
a table of contents in this file so people can easily jump around.

#+BEGIN_SRC emacs-lisp
  (use-package toc-org)
#+END_SRC
*** Add ~$$~ to highlight list
In Org-mode you use the dollar sign to enclose mathematical expressions, or
things you want exported marked up as LaTeX expressions, however there's no
syntax highlighting or hiding like with the other emphasis markers. After
/extensive/ research online I figured out that:

1. You can't extend the ~org-emphasis-alist~ anymore.
2. Regexp is a fucking mess, took me forever to figure this out.
3. Emacs regexp is different from all other regexps.

I also figured out a more beautiful version of the syntax below, but it broke
the highlighting in all org-mode documents, so that was fun. You can see it in
all its beauty in the comment in the code.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-font-lock-set-keywords-hook
            (lambda ()
              (add-to-list 'org-font-lock-extra-keywords
                           ;; '("\\$\\(.+?\\)\\$"
                           '("\\(\\$\\)\\([^\n\r\t]+?\\)\\(\\$\\)"
                             (1 '(face org-code invisible t))
                             (2 'org-code )
                             (3 '(face org-code invisible t))))))
#+END_SRC
** Agenda
One of the killer features of Org is the Agenda feature, basically allowing you
to organize and see your whole life in Emacs.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Documents/Org"
        org-default-notes-file "~/Documents/Org/refile.org"
        org-agenda-files '("~/Documents/Org"))
#+END_SRC

** Functions
*** Automagical tangling
I keep forgetting both to tangle this file when I'm working on it and to
byte compile my home directory whenever I save this file. I'll also add a hook
so that whenever we kill Emacs it runs this function to ensure everything is up
to date, all the time.

#+BEGIN_SRC emacs-lisp
  (defun my--tangle-byte-compile-org ()
    "Tangles emacs.org and byte compiles ~/.emacs.d/"
    (interactive)
    (when (equal (buffer-name)
                 (concat "emacs.org"))
      (org-babel-tangle)
      (byte-recompile-directory (expand-file-name user-emacs-directory) 0)))

  (add-hook 'after-save-hook #'my--tangle-byte-compile-org)
  (add-hook 'kill-emacs-hook #'my--tangle-byte-compile-org)
#+END_SRC
* Latex
After I started studying I decided that it was finally time to learn Latex and
all its joys of typesetting and such, I initially used sharelatex.com but it was
pretty annoying for the most part, especially since I didn't have access to any
of my favorite Emacs commands and tools. So here is my Latex setup.

** AUCTeX
Everyone who uses Latex and Emacs uses ~AUCTeX~ do to it, so I'll be following the
norm.

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex
    :init
    (progn
      (setq TeX-command-default "latexmk"
      TeX-command-force "latexmk"
      TeX-engine 'lualatex
      TeX-auto-save t
      TeX-parse-self t
      TeX-save-query nil
      TeX-PDF-mode t
      TeX-show-compilation nil
      TeX-syntactic-comment t
      TeX-clean-confirm t
      TeX-source-correlate-mode t
      TeX-source-correlate-method 'synctex
      TeX-source-correlate-start-server t
      LaTeX-fill-break-at-separators nil
      TeX-view-program-selection '((output-pdf "PDF Viewer"))
      TeX-view-program-list
      '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
      (add-hook 'LaTeX-mode-hook 'TeX-fold-mode)
      (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
      (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
      (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode)
      (add-hook 'LaTeX-mode-hook 'flyspell-mode)
      (add-hook 'LaTeX-mode-hook 'flyspell-buffer)))
#+END_SRC

And everyone seems to be using ~latexMK~ to automatically generate the ~PDF~-files.

#+BEGIN_SRC emacs-lisp
  (use-package auctex-latexmk
    :init
    (progn
      (setq auctex-latexmk-inherit-TeX-PDF-mode t)
      (auctex-latexmk-setup)))
#+END_SRC

Then we'll enable ~Company~ for it so we get some decent auto completion for
LaTeX.

#+BEGIN_SRC emacs-lisp
  (use-package company-auctex
    :init
    (progn
      (company-auctex-init)))
#+END_SRC

And finally we'll add ~magic-latex-buffer~ for some proper magic.

#+BEGIN_SRC emacs-lisp
  (use-package magic-latex-buffer
    :init
    (progn
      (add-hook 'LaTeX-mode-hook 'magic-latex-buffer)
      (setq magic-latex-enable-block-highlight t
            magic-latex-enable-suscript t
            magic-latex-enable-pretty-symbols t
            magic-latex-enable-block-align nil
            magic-latex-enable-inline-image nil)))
#+END_SRC
** RefTEX
Whenever you are writing a document that required references you'll need
something like ~RefTEX~ to keep them in proper order.

#+BEGIN_SRC emacs-lisp
  (use-package reftex
    :ensure nil
    :commands (turn-on-reftex reftex-mode)
    :init
    (progn
      (setq reftex-plug-into-AUCTeX t
            reftex-use-fonts t
            reftex-default-bibliography '("~/Documents/UiB/bibliography.bib")
            reftex-toc-split-windows-fraction 0.2))
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex))
#+END_SRC

And then we can configure ~bibtex~.

#+BEGIN_SRC emacs-lisp
  (use-package bibtex
    :ensure nil
    :config
    (progn
      (setq bibtex-dialect 'biblatex
            bibtex-align-at-equal-sign t
            bibtex-text-indentation 20
            bibtex-completion-bibliography '("~/Documents/UiB/bibliography.bib"))))
#+END_SRC
* Programming
Anything related to mostly anything related to programming goes here.

** LISP
And anything that has to do with languages related to LISP goes here.

*** Lispy
I've never used any of the older packages that manipulates s-expressions so I
have no idea how they compare, but I love all the other packages that ~abo-abo~
makes, so why not try this one too.

#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :config
    (progn
      (add-hook 'emacs-lisp-mode-hook #'lispy-mode)
      (define-key lispy-mode-map-lispy (kbd "\"") nil)))
#+END_SRC

And we'll use it together with ~Lispyville~ to provide some comfort when using
it together with ~Evil-mode~.

#+BEGIN_SRC emacs-lisp
  (use-package lispyville
    :after lispy
    :config
    (progn
      (add-hook 'lispy-mode-hook #'lispyville-mode)))
#+END_SRC
** SQL
There's a course at my university for databases, and I'm taking it and therefore
am in need of using databases. Most of the time I'm doing it in Emacs with
Org-mode, exporting the commands and results to a nice HTML-document so I can
easily go over my homework in a really nice way. However, it does need some
configuring.

#+BEGIN_SRC emacs-lisp
  (use-package sql
    :ensure nil
    :config
    (progn
      (setq sql-product 'mysql)))
#+END_SRC

And then since manually writing SQL statements and functions as upper case all
the time is really tedious we'll install a helper mode for that.

#+BEGIN_SRC emacs-lisp
  (use-package sqlup-mode
    :after sql
    :config
    (progn
      (add-hook 'sql-mode-hook 'sqlup-mode)
      (add-hook 'sql-interactive-mode-hook 'sqlup-mode)))
#+END_SRC
* Outro
** Late start settings

And this is where I leave you adieu. But not before powering down Emacs and
setting it up for actual usage. First I print the time it took to boot, Useful
to spot regressions in startup time for Emacs. Also not really useful because
who restarts Emacs.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda () (message (concat "Booted in: " (emacs-init-time))))
            (setq gc-cons-threshold (* 100 1024)
                  gc-cons-percentage 0.1))
#+END_SRC
