#+TITLE: Emacs settings
#+AUTHOR: Sondre Nilsen
#+EMAIL: nilsen.sondre@gmail.com
#+PROPERTY: header-args :tangle ~/.emacs.d/new-init.el

* Introduction
This is my Emacs configuration, there are many like it but this one is mine.
It's decently personalized, but it should be useful for either inspiration or
just straight-up copy-pasta. My configuration is managed by [[https://github.com/emacscollective/borg][borg]], and is a bit
weird in that the configuration lives in this directory but all the actual git
modules lives in a separate repository ([[https://github.com/sondr3/.emacs.d][~.emacs.d~]]).

I'm also running the latest major release of Emacs, which as of this writing is
version 26.1, so unless you're running this version I cannot guarantee that
everything works. It's also worth noting that I named my configuration
~Amalthea~, after a random moon on Jupiter. I had my reasons for this once, but
I can't remember why. I just think it's a cool name, so you'll see that name
reflected in quite a few variables and functions that I use.

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
  ;; (package-initialize)

  (unless (eq emacs-major-version 26)
    (error "Your version of Emacs isn't up-to-date"))
#+END_SRC

* Initialization
** Startup
First and foremost, we'll try to make Emacs load quicker by first disabling
~file-name-handler-alist~, mostly because we don't need it at boot and it's
really slow because it tries to look at all the files in the load path and check
if they are something Emacs can load.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (defconst amalthea--file-name-handler-alist file-name-handler-alist
      "Our own file-name-handler-alist, used after boot")
    (defconst amalthea--post-init-hook nil
      "Hook that runs after Emacs has loaded")
    (setq file-name-handler-alist nil)
    (add-hook 'amalthea--post-init-hook amalthea--file-name-handler-alist))
#+END_SRC

Then we can configure the various directories that we'll be using with Emacs,
mostly for caches and assorted stuff we don't want cluttering our computer, so
we'll put them in their own directories instead. We just need to make sure they
exist and can be used.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (defconst amalthea--emacs-dir (expand-file-name user-emacs-directory))
    (defconst amalthea--etc-dir (concat amalthea--emacs-dir "etc/"))
    (defconst amalthea--cache-dir (concat amalthea--emacs-dir "cache/"))

    (dolist (dir (list amalthea--emacs-dir amalthea--etc-dir amalthea--cache-dir))
      (unless (file-directory-p dir)
        (make-directory dir t))))
#+END_SRC

Next up we'll make the garbage collector a little less aggressive while booting
up to save a tiny amount of speed, but then at the end we'll make sure it's set
back to the default values.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq gc-cons-threshold 402653184
          gc-cons-percentage 0.6)

    (add-hook 'amalthea--post-init-hook #'(lambda ()
                                            (message "Resetting GC values.")
                                            (setq gc-cons-threshold 16777216
                                                  gc-cons-percentage 0.1))))
#+END_SRC
** ~Borg~ and ~use-package~
As I mentioned in the beginning of this file, I'm using Borg for managing all my
dependencies, as opposed to just using ~use-package~. I initially did this but
wanted to try something new. I switched to NixOS in the beginning of 2018, and
really came around to liking a reproducible environment with it. I initially
considered configuring Emacs with Nix, but in the end settled on using something
else as I wanted something closer to Emacs and not my OS. Which is ironic since
Emacs is an OS with a text editor on top.

Anyhow, we'll first need to set some settings before we jump into starting up
Borg and ~use-package~. The first two are just increases over the default since
we are now using computers with more memory and CPU that we had in the olden
days. Then we make sure that Emacs always loads newer files instead of the first
it finds in case we forget to byte compile a newly updated file, finally we
tell Emacs that we have initialize packages in the ~init.el~ file and not to
activate packages automatically and lastly we use the newest byte codes.

#+BEGIN_SRC emacs-lisp
  (defvar package--init-file-ensured)
  (setq max-lisp-eval-depth 50000
        max-specpdl-size 10000
        load-prefer-newer t
        package--init-file-ensured t
        package-enable-at-startup nil
        byte-compile--use-old-handlers nil)
#+END_SRC

Then we can load Borg and ~use-package~, by first adding all the various
packages we have downloaded to the load path, then initializing and loading both
Borg and ~use-package~, and then setting a few assorted settings for it. First
we enable verbose loading, which shows the time it takes to load and enable
various packages, then we compute statistics for all the packages. We can then
view how long it took to load packages the last time we started up, making it
easier to spot packages that makes Emacs spend too much time loading. Finally,
we always defer the loading of packages untill they are needed.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (add-to-list 'load-path (expand-file-name "lib/borg" user-emacs-directory))
    (require  'borg)
    (borg-initialize)
    (require  'use-package)
    (setq use-package-verbose t
          use-package-compute-statistics t
          use-package-always-defer t))
#+END_SRC

*** Helper packages
Using Borg with Emacs requires using a couple extra packages to be able to use
it to it's full potential. If you were to clone the [[https://github.com/emacscollective/emacs.g][emacs.g]] directory, which is
commonly used as the starting point for configuring Emacs with Borg, you'd get
quite a lot of packages included, but we don't really want most of them, just a
couple.

The first, is ~epkg~. It's a package that enables you to browse any and all
packages available for Emacs, which is really helpful when using Borg. I've had
it happen a few times when a package migrates but I haven't caught it and when I
try to update the repository doesn't exist. By using this and keeping it
refreshed I can double check that the URLs matches, or I can just use it to
quickly view information about a package.

#+BEGIN_SRC emacs-lisp
  (use-package epkg
    :init (setq epkg-repository
                (expand-file-name "var/epkgs/" user-emacs-directory)))
#+END_SRC

Then, and this isn't required per se, but I'll be using Delight to hide or
rename the names of major and minor modes on the modeline instead of Diminish.
Mostly because when I last checked it didn't support hiding major modes or
renaming them without weird hacks. And now that ~use-package~ has built-in support
for the ~:delight~ keyword, I don't really need it.

#+BEGIN_SRC emacs-lisp
  (use-package delight)
#+END_SRC
* Core settings
** Defaults
Emacs is nearly twice my age, and as such has a bunch of pretty funny defaults
that I deem necessary to change. Quite frankly, there's a lot of them and I have
probably missed a bunch of them too.

*** UTF8
Emacs actually predates UTF8, which to my mind is kinda nuts. So we'll force
Emacs to always use unicode characters and UTF8 everywhere.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'set-charset-priority)
    (set-charset-priority 'unicode))
  (prefer-coding-system                   'utf-8)
  (set-terminal-coding-system             'utf-8)
  (set-keyboard-coding-system             'utf-8)
  (set-selection-coding-system            'utf-8)
  (setq locale-coding-system              'utf-8)
  (setq-default buffer-file-coding-system 'utf-8)
#+END_SRC

*** To y or y
Mostly to save at most two strokes and at a minimum one. Efficiency baby.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Replace selected text properly
For some reason the default behaviour for Emacs is to not replace text you
have selected when you start typing but instead just start typing at the end of
the selection.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC
*** Custom file
Again, the default behaviour for Emacs is to append to the ~init.el~ file all the
assorted custom settings and whatnot, which annoys me. So we'll just make it so
it adds it to it's own ~custom.el~ file.

#+BEGIN_SRC emacs-lisp
  (use-package custom
    :no-require t
    :config
    (progn
      (setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
      (when (file-exists-p custom-file)
        (load custom-file t t))))
#+END_SRC
*** Startup messages
Whenever you start Emacs you normally get a nice enough startup screen giving
information about both Emacs, GNU and various other things. I don't like 'em so
we'll hide it all and just startup in ~*scratch*~ instead.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-buffer-menu t
        inhibit-startup-screen t
        inhibit-startup-echo-area-message t
        initial-buffer-choice t)
#+END_SRC
*** Disable bells
Because who on earth enjoys the sounds of bells sounding whenever you do
anything even remotely "wrong". Like reaching the top of a file. Or the bottom.
Or the edge. God. No.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil
        ring-bell-function #'ignore)
#+END_SRC
*** Backups
Emacs keeps a ton of assorted backup files all over the place, either in the
directory you're editing the file in, or in ~.emacs.d~ and so on. It's fairly
annoying to be honest. So we'll just place all the backup files in the cache
directory.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . ,(concat amalthea--cache-dir "saves/")))
        auto-save-file-name-transforms `((".*" ,(concat amalthea--cache-dir "auto-save") t))
        auto-save-list-file-name (concat amalthea--cache-dir "autosave")
        abbrev-file-name (concat amalthea--cache-dir "abbrev_defs")
        backup-by-copying t
        version-control t
        delete-old-versions t)
#+END_SRC
*** Indentation
Emacs defaults to both using tabs for indentation and the width for a tab
character is a whopping eight! That doesn't make any sense whatsoever. So we'll
make it sane, use spaces and with a width of two.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 2)
#+END_SRC
*** Line wrapping
Following the above, we'll use 80 as the default width for which to wrap text in
all modes, because that's modern. At least more modern than the default for
Emacs, which is a prehistoric 70.

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC
*** Whitespace
This is something that you could fix by using a builtin helper function that
removes newlines at the end of files etc, but I prefer using something called
~ws-butler~ which does this in a more thorough way.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :delight
    :commands (ws-butler-global-mode)
    :init (ws-butler-global-mode 1))
#+END_SRC
*** Assorted
And then some options that don't really warrant their own little heading.

#+BEGIN_SRC emacs-lisp
  (defvar compilation-scroll-output)
  (setq-default sentence-end-double-space nil   ;; no
                vc-follow-symlinks t)           ;; yes
  (setq help-window-select t                    ;; focus help window when opened
        compilation-scroll-output 'first-error  ;; stop at first error in compilation log
        save-interprogram-paste-before-kill t)  ;; save paste history globally
#+END_SRC
** Built-in modes
There's a ton of builtin modes in Emacs that are either very useful... or not so
much. Mostly very useful though, so much so that we'll configure quite a few of
them.

*** ~autorevert~
If you've ever experienced changing a file in a different program while it's
open in Emacs (for whatever reason) and then mistakenly overwriting it again
when you save it in Emacs because it hasn't been refreshed from disk? Worry no
more.

As for configuration, the only thing we'll change is that it doesn't just
refresh file buffers, but also buffers that indirectly have to do with files,
e.g. Dired buffers and such.

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :commands (global-auto-revert-mode)
    :init
    (setq global-auto-revert-non-file-buffers t)
    (global-auto-revert-mode))
#+END_SRC
*** ~recentf~
Instead of having to work your way to the most recently edited file(s) by
writing the path out again and again, Emacs has a built-in minor mode that keeps
track of the most recently visited files, which we'll use in conjunction with
Counsel to quickly be able to open recent files.

The way we load it is stolen from Spacemacs, which makes it so it's lazily
loaded when needed.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :commands (recentf-mode recentf-track-opened-file)
    :init
    (progn
      (add-hook 'find-file-hook (lambda () (unless recentf-mode
                                             (recentf-mode)
                                             (recentf-track-opened-file))))
      (setq recentf-save-file (concat amalthea--cache-dir "recentf")
            recentf-max-saved-items 1000
            recentf-auto-cleanup 'never
            recentf-filename-handlers '(abbreviate-file-name))))
#+END_SRC
*** ~savehist~
This is probably one of the easier minor modes to explain, so we'll keep it
brief: it saves a history of everything you do in a minibuffer.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :commands (savehist-mode)
    :init
    (progn
      (setq savehist-file (concat amalthea--cache-dir "savehist")
            enable-recursive-minibuffers t
            savehist-save-minibuffer-history t
            history-length 1000
            savehist-autosave-interval 60
            savehist-additional-variables '(mark-ring
                                            global-mark-ring
                                            search-ring
                                            regexp-search-ring
                                            extended-command-history))
      (savehist-mode t)))
#+END_SRC
*** ~saveplace~
Mostly the same as above, instead of keeping track of the history of what you
did in your minibuffers, it keeps track of where the cursor was last in a file
and saves that position so that when you reopen that file you'll start at the
same place as you left.

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :commands (save-place-mode)
    :init
    (progn
      (setq save-place-file (concat amalthea--cache-dir "places"))
      (save-place-mode)))
#+END_SRC
*** ~uniquify~
Whenever you have multiple files with the same name open, you need a way to
differentiate between the two of them. We'll make it so that two files with the
same name, it shows the full path instead of the default, which I quite frankly
don't remember.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :init
    (progn
      (setq uniquify-buffer-name-style 'forward)))
#+END_SRC
** Async
Emacs is famously singlethreaded, painfully so at times. ~async~ is a reasonably
simple package that gives you some easy ways to do things asyncronously in
Emacs, like tangling and byte compiling this file.

#+BEGIN_SRC emacs-lisp
  (use-package async
    :commands (async-start)
    :defines async-bytecomp-allowed-packages
    :config
    (progn
      (async-bytecomp-package-mode t)
      (setq async-bytecomp-allowed-packages '(all))))
#+END_SRC
* Appearance
Emacs is really ugly by default, at least compared to more contemporary
offerings like VSCode. So we'll do a little something of our own to make it look
good. I hope. I'm colorblind, so who knows.
** Theme
I'm a huge fan of minimalism, and given that I'm colorblind I also find that
most themes turn into a sort of hodgepodge of colors. Which I don't like. So far
the best theme I've found is a super simple grayscale theme called tao.

#+BEGIN_SRC emacs-lisp
  (use-package tao-theme
    :init (load-theme 'tao-yang t))
#+END_SRC
** Fonts
Also, the default font is really bad, but then again, so are most default fonts
that text editors use by default. So of course we'll change it. The best fone
I've found so far is ~Fira Mono~, from Mozilla. It's just... nice.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family "Fira Mono"
                      :height 80)
  (set-frame-font "Fira Mono" nil t)
#+END_SRC

We'll also change the line spacing, giving our text a bit more breathing room.

#+BEGIN_SRC emacs-lisp
  (setq-default line-spacing 0.15)
#+END_SRC
** Bars, bars, bars
The default frame for Emacs contains a menu and tool bar at the top and a scroll
bar at the side, which we won't need since we know Emacs.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode)
    (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
#+END_SRC
** Assorted
For visual settings that don't belong anywhere else or aren't worthy of their
own little header.

#+BEGIN_SRC emacs-lisp
  (setq-default cursor-type '(bar . 2)
                frame-title-format '("Amalthea :: %b"))
#+END_SRC
** Line numbers
Starting with Emacs 26.1, Emacs has a built-in line number mode written in C
that supports relative line numbers, like in Vim. This is awesome, because the
previous offerings had a whole bunch of drawbacks, either being really slow, or
not properly supporting relative line numbers in Org mode and so on. Thankfully
we now have a proper solution.

First, we set the relative line number to ~visual~, which counts the visible lines
on the screen. Otherwise headers that are folded in Org makes the line count go
haywire, next we set a default width for line numbers and ensure that it doesn't
get narrower or wider depending on the amount of lines in a file.

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers 'visual
                display-line-numbers-current-absolute t
                display-line-numbers-width 4
                display-line-numbers-widen nil)
#+END_SRC
** ~hl-line~
This is basically something that I learned to use and love from Vim, it
highlights the current line where the cursor is currently active. We enable this
minor mode globally, and then make it so it doesn't display in inactive windows.

#+BEGIN_SRC emacs-lisp
  (use-package hl-line
    :commands (global-hl-line-mode)
    :init (global-hl-line-mode t)
    :config
    (progn
      (setq global-hl-line-sticky-flag nil)))
#+END_SRC
* Keybindings
This is probably the hardest thing by far to configure and properly do in Emacs,
at least in my opinion. I could use something like Spacemacs or Doom which has a
proper consistent theme for keybindings, but that's no fun. Instead we'll roll
our own built around [[https://github.com/emacs-evil/evil][Evil]], [[https://github.com/noctuid/general.el][General.el]] and [[https://github.com/justbur/emacs-which-key][which-key]]. Lastly, we'll mimick how I
used to do things in Vim (and how Spacemacs does things) by letting ~SPC~ be our
leader key and ~,~ be our major mode leader key.

** ~which-key~
This is a really cool package, I initially discovered this from Spacemacs (as I
have done with a great many things). What it does is show you any and all
keybindings you can complete from the binding you just executed. For example, if
you are in Org-mode and run ~C-c~, ~which-key~ will show on the bottom of the screen
and show all the keybindings you can complete from there. It's really great for
discoverability.

We won't be doing any major changes, only changing the delay timer because I
find one second to be a bit too long to wait.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight
    :commands (which-key-mode)
    :config
    (progn
      (which-key-mode)
      (setq which-key-idle-delay 0.3)))
#+END_SRC
** General
~use-package~ has a built-in way of binding keys, but after having tried to use it
in a slightly more advanced way than just binding keys I've found that it
doesn't work as I would've liked it to do. Enter General: it's a whole framework
for binding keys in a really nice and consistent manner. We'll also configure
our leader keys using the constants we created in the introduction to keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :commands (general-define-key general-evil-setup)
    :config
    (progn
      (general-evil-setup)
      (general-create-definer amalthea--leader-key-def
        :prefix "SPC")
      (general-create-definer amalthea--major-leader-key-def
        :prefix ",")))
#+END_SRC
** Evil
And finally, the secret sauce to everything. Vim keybindings. I'm not even
remotely close to being very proficient in using Vim, but after having gotten
used to the bindings I cannot for the life of me not use it, everything else
just feels so... wrong. So we'll use it. And abuse it.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :config (evil-mode))
#+END_SRC
* Text editing
Settings for the various kinds of text files that we'll edit in Emacs, either
that be Markdown, Org or LaTeX, or for all of them.
** General
*** ~auto-fill-mode~
We set the default width of any kind of text to be wrapped at 80 characters
wide, now we'll just enable this for any and all text modes.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook #'auto-fill-mode)
#+END_SRC
** Org-mode
Probably the best thing since sliced bread, followed by Magit and then followed
by sliced bread. It's both a markup language for rich text editing, but also a
suite of tools for journaling, keeping an agenda, your todo-list and so much
more. I love it.

However, there's a whole buttload of configurations we can set, so I'll list
them in a table below to explain what they do instead of trying to explain in a
paragraph, because I'd write a book.

| Setting                          | Why                                                                         |
|----------------------------------+-----------------------------------------------------------------------------|
| ~org-src-fontify-natively~         | Always use syntax highlighting of code blocks                               |
| ~org-startup-with-inline-images~   | Always show images                                                          |
| ~org-startup-indented~             | Indent text according to the current header                                 |
| ~org-hide-emphasis-markers~        | Hides the symbols that makes text bold etc                                  |
| ~org-use-sub-superscripts~         | Always use ~{}~ to group sub/superscript text                                 |
| ~org-export-with-sub-superscripts~ | Export with the same syntax as above                                        |
| ~org-pretty-entities~              | Show entities as UTF8-characters when possible                              |
| ~org-list-allow-alphabetical~      | Makes it so lists can be something else than just 1) or just simple bullets |

#+BEGIN_SRC emacs-lisp
  (use-package org
    :delight org-indent-mode
    :defines org-export-with-sub-superscripts
    :config
    (progn
      (setq org-src-fontify-natively t
            org-startup-with-inline-images t
            org-startup-indented t
            org-hide-emphasis-markers t
            org-use-sub-superscripts '{}
            org-export-with-sub-superscripts '{}
            org-pretty-entities t
            org-list-allow-alphabetical t)))
#+END_SRC
* Programming
Any and all settings related in some way to programming, be it either
highlighting, matching parenthesises or general configuration for languages.
** General
For settings that are not specific to a single language or are useful for more
than one language.
*** Delimiters
Any and all settings related to delimiters, either it's making them look
glorious (rainbows) or just show matching delimiters.

**** ~paren-mode~
Does pretty much exactly what it says, it shows matching parenthesises (and
other delimiters as far as I'm aware too). As for settings, we'll set it so
there's no delay for showing it's long lost sister, always highlight open
parenthesises and show the matching pair when inside their block.

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :commands (show-paren-mode)
    :init (show-paren-mode t)
    :config
    (progn
      (setq-default show-paren-delay 0
                    show-paren-highlight-openparen t
                    show-paren-when-point-inside-paren t)))
#+END_SRC
**** ~rainbow-delimiters~
Pretty straight forward too, makes your rainbows dashing.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :commands (rainbow-delimiters-mode)
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
*** Indentation
Indentation in programming is different to just wrapping text when it reaches
it's maximum width, so we'll have to slightly configure it.
**** ~aggressive-indent~
And the first thing we'll do is to enable pretty aggressive indentation. The
normal way it works is that it only indents the local block, if at all, and
doesn't really care about the whole block. With this mode, in Elisp for example
it will indent the whole file if need be. It's really useful for programming
languages where indentation is easy to reason about.

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :delight
    :commands (aggressive-indent-mode)
    :init (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode))
#+END_SRC
*** ~electric-pair-mode~
This automatically creates a closing parenthesis or bracket (etc) whenever you
make a opening parenthesis or bracket (etc).

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'electric-pair-mode)
#+END_SRC
* Outro
And this is finally it, we can now run the post init hook and reset back all the
various settings we configured during our setup of Emacs. The last thing we need
to add is way to display how long it took Emacs to boot.

#+BEGIN_SRC emacs-lisp
  (add-hook 'amalthea--post-init-hook #'(lambda ()
                                          (message (concat "Booted in: " (emacs-init-time)))))
  (run-hooks 'amalthea--post-init-hook)
#+END_SRC
